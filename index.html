<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Virtuoso Web Piano</title>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
      :root {
        --bg-color: #1a1a1a;
        --panel-bg: #2d2d2d;
        --text-color: #e0e0e0;
        --accent: #4caf50;
        --white-key: #fffff0;
        --black-key: #111;
        --pressed-color: #ffd54f;
      }

      body {
        margin: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }

      /* Top Control Panel */
      .controls {
        padding: 10px 20px;
        background-color: var(--panel-bg);
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: space-between;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        z-index: 10;
      }

      .controls-left {
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
      }

      .controls-right {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      h1 {
        margin: 0;
        font-size: 1.2rem;
        color: var(--accent);
        margin-right: 20px;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
        border-right: 1px solid #444;
        padding-right: 15px;
      }

      .control-group:last-child {
        border: none;
      }

      button {
        background: #444;
        border: none;
        color: white;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        transition: 0.2s;
        font-size: 0.9rem;
      }

      button:hover {
        background: #555;
      }
      button.active {
        background: var(--accent);
        color: white;
      }
      button.danger {
        background: #d32f2f;
      }

      select,
      input[type="number"],
      input[type="range"] {
        background: #333;
        color: white;
        border: 1px solid #555;
        padding: 5px;
        border-radius: 4px;
      }

      /* Piano Container */
      .piano-container {
        flex-grow: 1;
        position: relative;
        overflow-x: auto;
        overflow-y: hidden;
        display: flex;
        justify-content: center;
        background: #000;
        box-shadow: inset 0 10px 20px rgba(0, 0, 0, 0.5);
      }

      .piano-keys {
        display: flex;
        position: relative;
        height: 100%;
        padding: 20px 0;
      }

      /* Keys */
      .key {
        position: relative;
        cursor: pointer;
        user-select: none;
        transition: background 0.1s;
        border-radius: 0 0 5px 5px;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
        padding-bottom: 10px;
        font-size: 0.8rem;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      }

      .key span {
        pointer-events: none;
        display: block;
        text-align: center;
      }
      .key-note {
        opacity: 0.5;
        font-size: 0.7rem;
        margin-bottom: 2px;
      }
      .key-bind {
        color: var(--accent);
        font-size: 0.9rem;
      }

      .key.white {
        background: var(--white-key);
        color: #333;
        width: 50px;
        height: 100%;
        z-index: 1;
        border: 1px solid #ccc;
        margin: 0 1px;
      }

      .key.black {
        background: var(--black-key);
        color: white;
        width: 34px;
        height: 60%;
        position: absolute;
        z-index: 2;
        top: 0;
        border: 1px solid #000;
        border-radius: 0 0 3px 3px;
      }

      .key.active {
        background: var(--pressed-color) !important;
        transform: scaleY(0.98);
        transform-origin: top;
      }

      /* Recorders Area */
      .recorder-panel {
        background: #222;
        padding: 10px;
        height: 120px;
        overflow-y: auto;
        border-top: 1px solid #444;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .track-item {
        display: flex;
        justify-content: space-between;
        background: #333;
        padding: 5px 10px;
        border-radius: 4px;
        align-items: center;
      }

      /* Modal */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        backdrop-filter: blur(4px);
      }

      .modal-content {
        background: var(--panel-bg);
        border-radius: 8px;
        padding: 25px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        border-bottom: 1px solid #444;
        padding-bottom: 15px;
      }

      .modal-header h2 {
        margin: 0;
        color: var(--accent);
        font-size: 1.5rem;
      }

      .modal-close {
        background: transparent;
        border: none;
        color: var(--text-color);
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background 0.2s;
      }

      .modal-close:hover {
        background: #444;
      }

      /* Song Editor */
      .editor-modal {
        max-width: 95%;
        width: 95%;
        max-height: 95vh;
        padding: 0;
        display: flex;
        flex-direction: column;
      }

      .editor-modal .modal-header {
        margin: 0;
        padding: 20px 25px;
        border-bottom: 1px solid #444;
      }

      .editor-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 25px;
        background: #252525;
        border-bottom: 1px solid #444;
        gap: 10px;
        flex-wrap: wrap;
      }

      .editor-toolbar-left,
      .editor-toolbar-right {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .editor-toolbar-right button {
        padding: 6px 12px;
        font-size: 0.85rem;
      }

      .editor-toolbar-right button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .editor-container {
        flex: 1;
        overflow: hidden;
        position: relative;
        background: #1a1a1a;
        min-height: 500px;
        height: 60vh;
      }

      .editor-canvas {
        width: 100%;
        height: 100%;
        display: block;
        cursor: default;
      }

      .editor-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 25px;
        background: #252525;
        border-top: 1px solid #444;
        gap: 15px;
      }

      .editor-info {
        display: flex;
        gap: 15px;
        color: #aaa;
        font-size: 0.9rem;
      }

      .editor-actions {
        display: flex;
        gap: 10px;
      }

      .song-list {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .song-item {
        background: #333;
        border-radius: 6px;
        padding: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background 0.2s;
        border: 1px solid #444;
      }

      .song-item:hover {
        background: #3a3a3a;
        border-color: var(--accent);
      }

      .song-info {
        flex: 1;
      }

      .song-title {
        font-size: 1.1rem;
        font-weight: bold;
        color: var(--text-color);
        margin-bottom: 5px;
      }

      .song-meta {
        font-size: 0.85rem;
        color: #aaa;
      }

      .song-actions {
        display: flex;
        gap: 10px;
      }

      button.primary {
        background: var(--accent);
        color: white;
      }

      button.primary:hover {
        background: #45a049;
      }

      .upload-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #444;
      }

      .upload-area {
        border: 2px dashed #555;
        border-radius: 6px;
        padding: 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        background: #2a2a2a;
      }

      .upload-area:hover {
        border-color: var(--accent);
        background: #333;
      }

      .upload-area.dragover {
        border-color: var(--accent);
        background: #3a3a3a;
      }

      input[type="file"] {
        display: none;
      }

      .upload-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        margin-top: 10px;
        transition: transform 0.2s;
      }

      .upload-button:hover {
        transform: scale(1.05);
      }

      .upload-status {
        margin-top: 10px;
        padding: 10px;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .upload-status.processing {
        background: #333;
        color: #ffa726;
      }

      .upload-status.success {
        background: #2d5a2d;
        color: #81c784;
      }

      .upload-status.error {
        background: #5a2d2d;
        color: #e57373;
      }

      .upload-preview {
        animation: slideDown 0.3s ease-out;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Utilities */
      .hidden {
        display: none !important;
      }
      label {
        font-size: 0.85rem;
        color: #aaa;
      }
    </style>
  </head>
  <body
    x-data="pianoApp()"
    x-init="init()"
    @keydown.window="handleKeyDown($event)"
    @keyup.window="handleKeyUp($event)"
  >
    <div class="controls">
      <div class="controls-left">
        <h1>üéπ Virtuoso</h1>

        <div class="control-group">
          <label>Mode:</label>
          <select x-model="inputMode" @change="updateKeyLabels()">
            <option value="real">Real Keys (q2w3...)</option>
            <option value="max">Max Keys (123...)</option>
            <option value="disabled">Disabled</option>
          </select>
        </div>

        <div class="control-group">
          <label>Start Octave:</label>
          <input
            type="number"
            x-model.number="octaveOffset"
            @change="updateKeyLabels()"
            min="1"
            max="6"
            style="width: 40px"
          />
        </div>

        <div class="control-group">
          <label>Sustain:</label>
          <select x-model="sustainMode" @change="handleSustainModeChange()">
            <option value="toggle">Toggle</option>
            <option value="hold">Hold</option>
          </select>
          <button
            x-text="`Sustain: ${sustain ? 'ON' : 'OFF'}`"
            :class="{ active: sustain }"
            @click="toggleSustain()"
          >
            Sustain: OFF
          </button>
          <button
            :class="{ active: showNotes }"
            @click="showNotes = !showNotes; updateKeyLabels()"
          >
            Show Notes
          </button>
        </div>

        <div class="control-group">
          <label>Metronome:</label>
          <input
            type="number"
            x-model.number="bpm"
            min="30"
            max="300"
            style="width: 50px"
          />
          <span>BPM</span>
          <select x-model.number="timeSig">
            <option value="4">4/4</option>
            <option value="3">3/4</option>
          </select>
          <button
            x-text="metronomeOn ? 'Stop' : 'Start'"
            :class="{ active: metronomeOn }"
            @click="toggleMetronome()"
          >
            Start
          </button>
        </div>

        <div class="control-group">
          <button
            x-text="isRecording ? '‚ñ† Stop & Save' : '‚óè Record'"
            :class="{ active: isRecording }"
            style="color: #ff5555"
            @click="toggleRecord()"
          >
            ‚óè Record
          </button>
          <div x-show="isRecording" x-text="recordingTime" class="hidden">
            00:00
          </div>
        </div>
      </div>

      <div class="controls-right">
        <button
          @click="showMarketplace = true; loadMarketplaceSongs()"
          style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%)"
        >
          üéµ Marketplace
        </button>
      </div>
    </div>

    <div class="piano-container">
      <div class="piano-keys" :style="{ width: pianoWidth + 'px' }">
        <template x-for="key in pianoKeys" :key="key.midi">
          <div
            :id="`key-${key.midi}`"
            :class="`key ${key.isBlack ? 'black' : 'white'}`"
            :style="key.isBlack ? { left: key.leftPos + 'px' } : {}"
            @mousedown="triggerNoteOn(key.midi)"
            @mouseup="triggerNoteOff(key.midi)"
            @mouseleave="triggerNoteOff(key.midi)"
          >
            <span
              class="key-note"
              x-text="`${key.noteName}${key.octave}`"
              :class="{ hidden: !showNotes }"
            ></span>
            <span class="key-bind" x-text="key.keyBind"></span>
          </div>
        </template>
      </div>
    </div>

    <div class="recorder-panel">
      <div
        style="
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 5px;
        "
      >
        <div style="display: flex; align-items: center; gap: 10px;">
          <strong>Saved Recordings</strong>
          <button
            @click="openEditor(null)"
            style="background: var(--accent); padding: 4px 12px; font-size: 0.85rem;"
          >
            + Create
          </button>
        </div>
        <label
          >Playback Vol:
          <input
            type="range"
            x-model.number="playbackVol"
            min="0"
            max="1"
            step="0.1"
        /></label>
      </div>
      <div>
        <template x-for="(rec, index) in recordings" :key="index">
          <div class="track-item">
            <span x-text="`${rec.name} (${rec.data.length} notes)`"></span>
            <div>
              <span
                x-show="playingRecordings.has(index)"
                style="margin-right: 10px; color: var(--accent)"
                x-text="getPlaybackTime(index)"
              ></span>
              <button
                x-text="playingRecordings.has(index) ? '‚è∏ Playing' : '‚ñ∂ Play'"
                @click="playRecording(index)"
              ></button>
              <button @click="openEditor(index)" style="background: #4488ff;">Edit</button>
              <button class="danger" @click="deleteRecording(index)">X</button>
            </div>
          </div>
        </template>
      </div>
    </div>

    <!-- Marketplace Modal -->
    <div
      x-show="showMarketplace"
      class="modal-overlay"
      @click.self="showMarketplace = false; stopPreview()"
      x-transition
    >
      <div class="modal-content" @click.stop>
        <div class="modal-header">
          <h2>üéµ Song Marketplace</h2>
          <button
            class="modal-close"
            @click="showMarketplace = false; stopPreview()"
          >
            √ó
          </button>
        </div>
        <div class="upload-section">
          <div
            class="upload-area"
            @click="$refs.midiInput.click()"
            @dragover.prevent="uploadDragOver = true"
            @dragleave.prevent="uploadDragOver = false"
            @drop.prevent="handleFileDrop($event)"
            :class="{ dragover: uploadDragOver }"
          >
            <div>üéµ Upload MIDI File</div>
            <div style="font-size: 0.8rem; color: #aaa; margin-top: 5px">
              Drag & drop or click to select<br />
              <span style="font-size: 0.75rem"
                >Supports: MIDI (.mid, .midi)</span
              >
            </div>
            <input
              type="file"
              x-ref="midiInput"
              accept=".mid,.midi"
              @change="handleFileUpload($event)"
            />
          </div>
          <div
            x-show="uploadStatus"
            class="upload-status"
            :class="uploadStatusType"
            x-text="uploadStatus"
          ></div>

          <!-- Preview and Edit Section -->
          <div
            x-show="uploadPreview"
            class="upload-preview"
            style="
              margin-top: 20px;
              padding: 15px;
              background: #2a2a2a;
              border-radius: 6px;
              border: 1px solid #444;
            "
          >
            <div style="margin-bottom: 15px">
              <strong style="color: var(--accent)">Preview & Edit</strong>
            </div>

            <div
              style="
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
              "
            >
              <div>
                <label
                  style="display: block; margin-bottom: 5px; font-size: 0.85rem"
                  >Song Name:</label
                >
                <input
                  type="text"
                  x-model="uploadPreview.name"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #333;
                    color: white;
                    border: 1px solid #555;
                    border-radius: 4px;
                  "
                />
              </div>

              <div>
                <label
                  style="display: block; margin-bottom: 5px; font-size: 0.85rem"
                  >Composer/Author:</label
                >
                <input
                  type="text"
                  x-model="uploadPreview.composer"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #333;
                    color: white;
                    border: 1px solid #555;
                    border-radius: 4px;
                  "
                />
              </div>

              <div>
                <label
                  style="display: block; margin-bottom: 5px; font-size: 0.85rem"
                  >Description:</label
                >
                <textarea
                  x-model="uploadPreview.description"
                  rows="2"
                  style="
                    width: 100%;
                    padding: 8px;
                    background: #333;
                    color: white;
                    border: 1px solid #555;
                    border-radius: 4px;
                    resize: vertical;
                  "
                ></textarea>
              </div>

              <div>
                <label
                  style="display: block; margin-bottom: 5px; font-size: 0.85rem"
                >
                  Tempo Multiplier:
                  <span x-text="uploadPreview.tempoMultiplier.toFixed(2)"></span
                  >x
                </label>
                <input
                  type="range"
                  x-model.number="uploadPreview.tempoMultiplier"
                  min="0.05"
                  max="4"
                  step="0.05"
                  @input="updatePreviewTempo()"
                  style="width: 100%"
                />
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    font-size: 0.75rem;
                    color: #aaa;
                    margin-top: 5px;
                  "
                >
                  <span>0.05x (Slower)</span>
                  <span>1.0x (Normal)</span>
                  <span>4.0x (Faster)</span>
                </div>
              </div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 15px">
              <button
                class="primary"
                @click="playPreview()"
                x-text="previewPlaying ? '‚è∏ Stop Preview' : '‚ñ∂ Play Preview'"
              ></button>
              <button
                @click="saveUploadedSong()"
                style="background: var(--accent); color: white"
              >
                üíæ Save to Songs
              </button>
              <button class="danger" @click="cancelUpload()">‚úï Cancel</button>
            </div>
          </div>
        </div>
        <div class="song-list">
          <template x-for="(song, index) in marketplaceSongs" :key="index">
            <div class="song-item">
              <div class="song-info">
                <div class="song-title" x-text="song.name"></div>
                <div class="song-meta">
                  <span x-text="song.composer"></span>
                  <span x-show="song.description"> ‚Ä¢ </span>
                  <span x-text="song.description"></span>
                  <span> ‚Ä¢ </span>
                  <span
                    x-text="`${song.data ? song.data.length : 0} notes`"
                  ></span>
                </div>
              </div>
              <div class="song-actions">
                <button
                  class="primary"
                  @click="importSong(song)"
                  x-text="isSongImported(song) ? '‚úì Imported' : '‚¨á Download'"
                  :disabled="isSongImported(song)"
                >
                  ‚¨á Download
                </button>
              </div>
            </div>
          </template>
          <div
            x-show="marketplaceSongs.length === 0"
            style="text-align: center; color: #aaa; padding: 20px"
          >
            Loading songs...
          </div>
        </div>
      </div>
    </div>

    <!-- Song Editor Modal -->
    <div
      x-show="showEditor"
      class="modal-overlay"
      @click.self="closeEditor()"
      x-transition
    >
      <div class="modal-content editor-modal" @click.stop>
        <div class="modal-header">
          <h2>üéº Song Editor</h2>
          <button class="modal-close" @click="closeEditor()">√ó</button>
        </div>
        <div class="editor-toolbar">
          <div class="editor-toolbar-left">
            <input
              type="text"
              x-model="editorName"
              placeholder="Song name..."
              style="
                padding: 6px 12px;
                background: #333;
                color: white;
                border: 1px solid #555;
                border-radius: 4px;
                font-size: 0.9rem;
                min-width: 200px;
              "
            />
          </div>
          <div class="editor-toolbar-right">
            <button
              @click="editorCopy()"
              :disabled="editorSelectedCount === 0"
              title="Copy (Ctrl+C)"
            >
              üìã Copy
            </button>
            <button
              @click="editorPaste()"
              :disabled="editorClipboard.length === 0"
              title="Paste (Ctrl+V)"
            >
              üìÑ Paste
            </button>
            <button
              @click="editorDelete()"
              :disabled="editorSelectedCount === 0"
              class="danger"
              title="Delete (Delete)"
            >
              üóë Delete
            </button>
            <button
              @click="editorSelectAll()"
              title="Select All (Ctrl+A)"
            >
              ‚òë Select All
            </button>
            <button
              @click="editorDeselectAll()"
              :disabled="editorSelectedCount === 0"
            >
              ‚òê Deselect
            </button>
          </div>
        </div>
        <div class="editor-container">
          <canvas
            x-ref="editorCanvas"
            class="editor-canvas"
            @contextmenu.prevent
          ></canvas>
        </div>
        <div class="editor-footer">
          <div class="editor-info">
            <span x-text="`${editorNotes.length} notes`"></span>
            <span x-show="editorSelectedCount > 0"
              x-text="`${editorSelectedCount} selected`"></span>
          </div>
          <div class="editor-actions">
            <button @click="editorPlay()" x-text="editorPlaying ? '‚è∏ Stop' : '‚ñ∂ Play'"></button>
            <button @click="closeEditor()" class="danger">Cancel</button>
            <button @click="editorSave()" style="background: var(--accent);">
              üíæ Save
            </button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      /**
       * üéπ PIANO APP LOGIC - Alpine.js Version
       */

      import { SongEditor, eventsToNotes, notesToEvents } from "./src/songEditor.js";

      // Constants
      const REAL_KEYS_MAP = "q2w3er5t6y7ui9o0pzsxdcfvbhnjm,l.;/'";
      const MAX_KEYS_MAP = "1234567890qwertyuiopasdfghjklzxcvbnm";
      const NOTES = [
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#",
        "A",
        "A#",
        "B",
      ];

      // Audio context and samplers (shared)
      const AUDIO_CTX = new (window.AudioContext ||
        window.webkitAudioContext)();
      let masterGain = AUDIO_CTX.createGain();
      masterGain.connect(AUDIO_CTX.destination);
      masterGain.gain.value = 0.5;

      let MIDI;
      let MetroSampler;
      let loadedCount = 0;

      function checkLoadStatus() {
        loadedCount++;
        if (loadedCount >= 2) {
          console.log("All samples loaded.");
        }
      }

      // Initialize Tone.js samplers
      MIDI = new Tone.Sampler({
        urls: {
          C1: "24.mp3",
          C2: "36.mp3",
          C3: "48.mp3",
          C4: "60.mp3",
          C5: "72.mp3",
          C6: "84.mp3",
          C7: "96.mp3",
          F1: "29.mp3",
          F2: "41.mp3",
          F3: "53.mp3",
          F4: "65.mp3",
          F5: "77.mp3",
          G5: "79.mp3",
          E4: "64.mp3",
          A4: "69.mp3",
        },
        attack: 0.16,
        release: 1,
        volume: -8,
        baseUrl: "./assets/",
        onload: () => {
          console.log("Piano Samples Loaded");
          checkLoadStatus();
        },
      }).toDestination();

      MetroSampler = new Tone.Sampler({
        urls: {
          A1: "metro-hi-final.mp3",
          A2: "metro-low-final.mp3",
        },
        attack: 0.01,
        release: 1,
        volume: -6,
        baseUrl: "./assets/",
        onload: () => {
          console.log("Metronome Samples Loaded");
          checkLoadStatus();
        },
      }).toDestination();

      function pianoApp() {
        return {
          // State
          sustain: false,
          sustainMode: "toggle",
          sustainBeforeHold: false,
          showNotes: true,
          inputMode: "real",
          octaveOffset: 3,
          isRecording: false,
          startTime: 0,
          recordingTimerInterval: null,
          currentRecording: [],
          recordingTime: "00:00",
          metronomeOn: false,
          metroTimer: null,
          bpm: 100,
          timeSig: 4,
          playbackVol: 0.8,
          pianoKeys: [],
          pianoWidth: 0,
          recordings: [],
          playingRecordings: new Map(),
          playbackTimerInterval: null,
          playbackTimerTick: 0, // Reactive property to trigger updates
          showMarketplace: false,
          marketplaceSongs: [],
          uploadDragOver: false,
          uploadStatus: "",
          uploadStatusType: "",
          uploadPreview: null,
          previewPlaying: false,
          previewPlaybackInfo: null,
          // Editor state
          showEditor: false,
          editorInstance: null,
          editorName: "",
          editorNotes: [],
          editorClipboard: [],
          editorPlaying: false,
          editorPlaybackInfo: null,
          editorKeyHandler: null,
          editorResizeObserver: null,

          init() {
            this.initPiano();
            this.loadRecordings();
            this.startPlaybackTimer();
            this.loadMarketplaceSongs();
          },

          initPiano() {
            this.pianoKeys = [];
            let whiteKeyOffset = 0;

            for (let i = 0; i < 88; i++) {
              const midiNote = i + 21;
              const noteName = NOTES[midiNote % 12];
              const octave = Math.floor(midiNote / 12) - 1;
              const isBlack = noteName.includes("#");

              const key = {
                midi: midiNote,
                noteName: noteName,
                octave: octave,
                isBlack: isBlack,
                leftPos: isBlack ? whiteKeyOffset * 52 - 17 : 0,
                keyBind: "",
              };

              if (!isBlack) {
                whiteKeyOffset++;
              }

              this.pianoKeys.push(key);
            }

            this.pianoWidth = whiteKeyOffset * 52;
            this.updateKeyLabels();
          },

          updateKeyLabels() {
            // Clear all binds
            this.pianoKeys.forEach((key) => (key.keyBind = ""));

            if (this.inputMode === "disabled") return;

            const startMidi = (this.octaveOffset + 1) * 12;

            if (this.inputMode === "real") {
              for (let i = 0; i < REAL_KEYS_MAP.length; i++) {
                const char = REAL_KEYS_MAP[i];
                const targetMidi = startMidi + i;
                const key = this.pianoKeys.find((k) => k.midi === targetMidi);
                if (key) key.keyBind = char.toUpperCase();
              }
            } else if (this.inputMode === "max") {
              let currentWhiteMidi = startMidi;

              for (let i = 0; i < MAX_KEYS_MAP.length; i++) {
                const char = MAX_KEYS_MAP[i];

                while (NOTES[currentWhiteMidi % 12].includes("#")) {
                  currentWhiteMidi++;
                }

                const key = this.pianoKeys.find(
                  (k) => k.midi === currentWhiteMidi
                );
                if (key) key.keyBind = char.toUpperCase();

                currentWhiteMidi++;
              }
            }
          },

          handleKeyDown(e) {
            // Handle spacebar for sustain control
            if (e.key === " " || e.key === "Spacebar") {
              e.preventDefault();
              if (this.sustainMode === "hold") {
                this.sustainBeforeHold = this.sustain;
                this.sustain = !this.sustain;
              } else if (this.sustainMode === "toggle") {
                this.sustain = !this.sustain;
              }
              return;
            }

            if (this.inputMode === "disabled") return;
            if (e.repeat) return;
            if (e.target.tagName === "INPUT") return;

            const key = e.key.toLowerCase();
            const shift = e.shiftKey;
            const startMidi = (this.octaveOffset + 1) * 12;
            let targetMidi = -1;

            if (this.inputMode === "real") {
              const index = REAL_KEYS_MAP.indexOf(key);
              if (index > -1) targetMidi = startMidi + index;
            } else if (this.inputMode === "max") {
              const index = MAX_KEYS_MAP.indexOf(key);
              if (index > -1) {
                let wCount = 0;
                let current = startMidi;
                while (true) {
                  if (!NOTES[current % 12].includes("#")) {
                    if (wCount === index) break;
                    wCount++;
                  }
                  current++;
                }

                targetMidi = current;

                if (shift) {
                  const noteName = NOTES[targetMidi % 12];
                  if (noteName !== "E" && noteName !== "B") {
                    targetMidi++;
                  }
                }
              }
            }

            if (targetMidi > -1 && targetMidi < 109) {
              this.triggerNoteOn(targetMidi);
            }
          },

          handleKeyUp(e) {
            if (e.key === " " || e.key === "Spacebar") {
              e.preventDefault();
              if (this.sustainMode === "hold") {
                this.sustain = this.sustainBeforeHold;
              }
              return;
            }

            if (this.inputMode === "disabled") return;
            if (e.target.tagName === "INPUT") return;

            const key = e.key.toLowerCase();
            const shift = e.shiftKey;
            const startMidi = (this.octaveOffset + 1) * 12;
            let targetMidi = -1;

            if (this.inputMode === "real") {
              const index = REAL_KEYS_MAP.indexOf(key);
              if (index > -1) targetMidi = startMidi + index;
            } else if (this.inputMode === "max") {
              const index = MAX_KEYS_MAP.indexOf(key);
              if (index > -1) {
                let wCount = 0;
                let current = startMidi;
                while (true) {
                  if (!NOTES[current % 12].includes("#")) {
                    if (wCount === index) break;
                    wCount++;
                  }
                  current++;
                }

                targetMidi = current;

                if (shift) {
                  const noteName = NOTES[targetMidi % 12];
                  if (noteName !== "E" && noteName !== "B") {
                    targetMidi++;
                  }
                }
              }
            }

            if (targetMidi > -1 && targetMidi < 109) {
              this.triggerNoteOff(targetMidi);
            }
          },

          playMIDINote(midi) {
            const noteName = NOTES[midi % 12] + Math.floor(midi / 12 - 1);
            MIDI.triggerAttack(noteName);
            return noteName;
          },

          stopMIDINote(midi, sustainOverride = null) {
            const noteName = NOTES[midi % 12] + Math.floor(midi / 12 - 1);
            const shouldSustain =
              sustainOverride !== null ? sustainOverride : this.sustain;
            if (!shouldSustain) {
              MIDI.triggerRelease(noteName);
            }
          },

          triggerNoteOn(midi) {
            const key = this.pianoKeys.find((k) => k.midi === midi);
            if (!key) return;

            // Add active class via DOM manipulation (Alpine doesn't track this)
            const keyEl = document.getElementById(`key-${midi}`);
            if (keyEl) keyEl.classList.add("active");

            const noteName = this.playMIDINote(midi);

            if (this.isRecording) {
              this.currentRecording.push({
                time: (performance.now() - this.startTime) / 1000,
                type: "on",
                midi: midi,
                sustain: this.sustain,
              });
            }
          },

          triggerNoteOff(midi) {
            const keyEl = document.getElementById(`key-${midi}`);
            if (keyEl) keyEl.classList.remove("active");

            this.stopMIDINote(midi);

            if (this.isRecording) {
              this.currentRecording.push({
                time: (performance.now() - this.startTime) / 1000,
                type: "off",
                midi: midi,
                sustain: this.sustain,
              });
            }
          },

          toggleSustain() {
            if (this.sustainMode === "toggle") {
              this.sustain = !this.sustain;
            }
          },

          handleSustainModeChange() {
            this.sustain = false;
            this.sustainBeforeHold = false;
          },

          toggleMetronome() {
            this.metronomeOn = !this.metronomeOn;

            if (this.metronomeOn) {
              this.runMetronome();
            } else {
              clearTimeout(this.metroTimer);
            }
          },

          runMetronome() {
            const interval = 60000 / this.bpm;
            const beats = this.timeSig;
            let beatCount = 0;

            const tick = () => {
              if (!this.metronomeOn) return;

              const isDownbeat = beatCount % beats === 0;
              MetroSampler.triggerAttackRelease(isDownbeat ? "A1" : "A2", 0.1);

              beatCount++;
              this.metroTimer = setTimeout(tick, interval);
            };

            tick();
          },

          toggleRecord() {
            if (!this.isRecording) {
              this.isRecording = true;
              this.currentRecording = [];
              this.startTime = performance.now();
              this.recordingTime = "00:00";
              this.recordingTimerInterval = setInterval(() => {
                const elapsed = (performance.now() - this.startTime) / 1000;
                const minutes = Math.floor(elapsed / 60);
                const seconds = Math.floor(elapsed % 60);
                this.recordingTime = `${String(minutes).padStart(
                  2,
                  "0"
                )}:${String(seconds).padStart(2, "0")}`;
              }, 100);
            } else {
              this.isRecording = false;
              if (this.recordingTimerInterval) {
                clearInterval(this.recordingTimerInterval);
                this.recordingTimerInterval = null;
              }
              this.saveRecording();
            }
          },

          saveRecording() {
            if (this.currentRecording.length === 0) return;

            const name = prompt(
              "Name your masterpiece:",
              `Recording ${new Date().toLocaleTimeString()}`
            );
            if (!name) return;

            const saved = JSON.parse(
              localStorage.getItem("pianoRecordings") || "[]"
            );
            saved.push({ name: name, data: this.currentRecording });
            localStorage.setItem("pianoRecordings", JSON.stringify(saved));
            this.loadRecordings();
          },

          loadRecordings() {
            this.recordings = JSON.parse(
              localStorage.getItem("pianoRecordings") || "[]"
            );
          },

          formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(mins).padStart(2, "0")}:${String(secs).padStart(
              2,
              "0"
            )}`;
          },

          getPlaybackTime(index) {
            const playbackInfo = this.playingRecordings.get(index);
            if (!playbackInfo) return "";

            const elapsed = (performance.now() - playbackInfo.startTime) / 1000;
            return `${this.formatTime(elapsed)}/${this.formatTime(
              playbackInfo.duration
            )}`;
          },

          startPlaybackTimer() {
            if (this.playbackTimerInterval) return;
            this.playbackTimerInterval = setInterval(() => {
              // Update reactive property to trigger re-render
              this.playbackTimerTick++;
            }, 100);
          },

          playRecording(index) {
            if (this.playingRecordings.has(index)) {
              this.stopPlayback(index);
              return;
            }

            const track = this.recordings[index];
            if (!track) return;

            const sortedEvents = [...track.data].sort(
              (a, b) => a.time - b.time
            );
            const lastEvent = sortedEvents[sortedEvents.length - 1];
            const duration = lastEvent ? lastEvent.time + 0.5 : 0;

            const playbackInfo = {
              nodes: [],
              startTime: performance.now(),
              duration: duration,
              timerInterval: null,
            };

            this.playingRecordings.set(index, playbackInfo);

            // Ensure playback timer is running
            this.startPlaybackTimer();

            sortedEvents.forEach((event) => {
              const delayMs = event.time * 1000;

              const timer = setTimeout(() => {
                const midi = event.midi;
                const noteName = NOTES[midi % 12] + Math.floor(midi / 12 - 1);
                const keyEl = document.getElementById(`key-${midi}`);

                if (event.type === "on") {
                  if (keyEl) keyEl.classList.add("active");
                  MIDI.triggerAttack(noteName, undefined, this.playbackVol);
                } else if (event.type === "off") {
                  const wasSustained = event.sustain === true;
                  if (!wasSustained) {
                    MIDI.triggerRelease(noteName);
                  }
                  if (keyEl) keyEl.classList.remove("active");
                }
              }, delayMs);

              playbackInfo.nodes.push(timer);
            });

            const cleanupTimer = setTimeout(() => {
              this.stopPlayback(index);
            }, duration * 1000 + 100);

            playbackInfo.nodes.push(cleanupTimer);
          },

          stopPlayback(index) {
            const playbackInfo = this.playingRecordings.get(index);
            if (!playbackInfo) return;

            playbackInfo.nodes.forEach((n) => {
              if (typeof n === "number") {
                clearTimeout(n);
              }
            });

            if (playbackInfo.timerInterval) {
              clearInterval(playbackInfo.timerInterval);
            }

            this.playingRecordings.delete(index);

            // Stop global timer if no recordings are playing
            if (
              this.playingRecordings.size === 0 &&
              this.playbackTimerInterval
            ) {
              clearInterval(this.playbackTimerInterval);
              this.playbackTimerInterval = null;
            }
          },

          deleteRecording(index) {
            if (this.playingRecordings.has(index)) {
              this.stopPlayback(index);
            }

            const saved = JSON.parse(
              localStorage.getItem("pianoRecordings") || "[]"
            );
            saved.splice(index, 1);
            localStorage.setItem("pianoRecordings", JSON.stringify(saved));

            const newPlayingRecordings = new Map();
            this.playingRecordings.forEach((playbackInfo, oldIndex) => {
              if (oldIndex < index) {
                newPlayingRecordings.set(oldIndex, playbackInfo);
              } else if (oldIndex > index) {
                newPlayingRecordings.set(oldIndex - 1, playbackInfo);
              }
            });
            this.playingRecordings = newPlayingRecordings;

            this.loadRecordings();
          },

          async loadMarketplaceSongs() {
            this.marketplaceSongs = [];

            try {
              // Load manifest to get list of available songs
              const manifestResponse = await fetch("./songs/manifest.json");
              if (manifestResponse.ok) {
                const manifest = await manifestResponse.json();
                const songFiles = manifest.songs || [];

                // Load each song file
                for (const file of songFiles) {
                  try {
                    const response = await fetch(`./songs/${file}`);
                    if (response.ok) {
                      const song = await response.json();
                      this.marketplaceSongs.push(song);
                    }
                  } catch (error) {
                    console.error(`Failed to load ${file}:`, error);
                  }
                }
              } else {
                // Fallback: try to load known songs if manifest doesn't exist
                const fallbackFiles = [
                  "fur-elise.json",
                  "fur-elise-real.json",
                  "clair-de-lune.json",
                ];
                for (const file of fallbackFiles) {
                  try {
                    const response = await fetch(`./songs/${file}`);
                    if (response.ok) {
                      const song = await response.json();
                      this.marketplaceSongs.push(song);
                    }
                  } catch (error) {
                    console.error(`Failed to load ${file}:`, error);
                  }
                }
              }
            } catch (error) {
              console.error("Failed to load marketplace songs:", error);
            }
          },

          isSongImported(song) {
            return this.recordings.some((rec) => rec.name === song.name);
          },

          importSong(song) {
            if (this.isSongImported(song)) {
              return;
            }

            const saved = JSON.parse(
              localStorage.getItem("pianoRecordings") || "[]"
            );
            saved.push({
              name: song.name,
              data: song.data || [],
            });
            localStorage.setItem("pianoRecordings", JSON.stringify(saved));
            this.loadRecordings();
          },

          handleFileDrop(event) {
            this.uploadDragOver = false;
            const files = event.dataTransfer.files;
            if (files.length > 0) {
              this.processFile(files[0]);
            } else {
              this.uploadStatus = "Please drop a file";
              this.uploadStatusType = "error";
              setTimeout(() => {
                this.uploadStatus = "";
                this.uploadStatusType = "";
              }, 3000);
            }
          },

          handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
              this.processFile(file);
            } else {
              this.uploadStatus = "Please select a file";
              this.uploadStatusType = "error";
              setTimeout(() => {
                this.uploadStatus = "";
                this.uploadStatusType = "";
              }, 3000);
            }
            // Reset input
            event.target.value = "";
          },

          async processFile(file) {
            const fileName = file.name.toLowerCase();
            const fileType = file.type;

            if (
              fileType === "audio/midi" ||
              fileType === "audio/mid" ||
              fileName.endsWith(".mid") ||
              fileName.endsWith(".midi")
            ) {
              await this.processMidiFile(file);
            } else {
              this.uploadStatus =
                "Unsupported file type. Please upload MIDI files (.mid, .midi).";
              this.uploadStatusType = "error";
              setTimeout(() => {
                this.uploadStatus = "";
                this.uploadStatusType = "";
              }, 5000);
            }
          },

          async processMidiFile(file) {
            this.uploadStatus = "Processing MIDI file...";
            this.uploadStatusType = "processing";

            try {
              const arrayBuffer = await file.arrayBuffer();
              const songData = this.parseMidiFile(arrayBuffer, file.name);

              if (songData && songData.data.length > 0) {
                // Store original file for saving
                this.uploadPreview = {
                  name: songData.name,
                  composer: songData.composer || "Unknown",
                  description: songData.description || "",
                  data: songData.data,
                  originalData: songData.data, // Keep original for tempo adjustment
                  tempoMultiplier: 1.0,
                  file: file,
                  fileName: file.name,
                };

                this.uploadStatus = "MIDI file loaded! Preview and edit below.";
                this.uploadStatusType = "success";
                setTimeout(() => {
                  this.uploadStatus = "";
                  this.uploadStatusType = "";
                }, 3000);
              } else {
                this.uploadStatus = "Could not parse MIDI file.";
                this.uploadStatusType = "error";
                setTimeout(() => {
                  this.uploadStatus = "";
                  this.uploadStatusType = "";
                }, 7000);
              }
            } catch (error) {
              console.error("MIDI processing error:", error);
              this.uploadStatus = "Error processing MIDI: " + error.message;
              this.uploadStatusType = "error";
              setTimeout(() => {
                this.uploadStatus = "";
                this.uploadStatusType = "";
              }, 7000);
            }
          },

          updatePreviewTempo() {
            if (!this.uploadPreview) return;

            const multiplier = this.uploadPreview.tempoMultiplier;
            const originalData = this.uploadPreview.originalData;

            // Adjust timing based on tempo multiplier
            this.uploadPreview.data = originalData.map((event) => ({
              ...event,
              time: event.time / multiplier,
            }));
          },

          playPreview() {
            if (this.previewPlaying) {
              this.stopPreview();
              return;
            }

            if (!this.uploadPreview || !this.uploadPreview.data) return;

            this.previewPlaying = true;
            const sortedEvents = [...this.uploadPreview.data].sort(
              (a, b) => a.time - b.time
            );
            const lastEvent = sortedEvents[sortedEvents.length - 1];
            const duration = lastEvent ? lastEvent.time + 0.5 : 0;

            this.previewPlaybackInfo = {
              nodes: [],
              startTime: performance.now(),
              duration: duration,
            };

            sortedEvents.forEach((event) => {
              const delayMs = event.time * 1000;

              const timer = setTimeout(() => {
                const midi = event.midi;
                const noteName = NOTES[midi % 12] + Math.floor(midi / 12 - 1);
                const keyEl = document.getElementById(`key-${midi}`);

                if (event.type === "on") {
                  if (keyEl) keyEl.classList.add("active");
                  MIDI.triggerAttack(noteName, undefined, this.playbackVol);
                } else if (event.type === "off") {
                  const wasSustained = event.sustain === true;
                  if (!wasSustained) {
                    MIDI.triggerRelease(noteName);
                  }
                  if (keyEl) keyEl.classList.remove("active");
                }
              }, delayMs);

              this.previewPlaybackInfo.nodes.push(timer);
            });

            const cleanupTimer = setTimeout(() => {
              this.stopPreview();
            }, duration * 1000 + 100);

            this.previewPlaybackInfo.nodes.push(cleanupTimer);
          },

          stopPreview() {
            if (this.previewPlaybackInfo) {
              this.previewPlaybackInfo.nodes.forEach((n) => {
                if (typeof n === "number") {
                  clearTimeout(n);
                }
              });
              this.previewPlaybackInfo = null;
            }
            this.previewPlaying = false;

            // Remove all active key classes
            document.querySelectorAll(".key.active").forEach((el) => {
              el.classList.remove("active");
            });
          },

          cancelUpload() {
            this.stopPreview();
            this.uploadPreview = null;
            this.uploadStatus = "";
            this.uploadStatusType = "";
          },

          async saveUploadedSong() {
            if (!this.uploadPreview) return;

            try {
              // Create song object
              const songData = {
                name: this.uploadPreview.name,
                composer: this.uploadPreview.composer,
                description: this.uploadPreview.description,
                data: this.uploadPreview.data,
              };

              // Generate filename
              const sanitizedName = this.uploadPreview.name
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, "-")
                .replace(/^-+|-+$/g, "");
              const fileName = `${sanitizedName}.json`;

              // Save file to songs folder (we'll need to use a download approach since we can't write to server)
              // For now, save to localStorage and add to manifest
              const blob = new Blob([JSON.stringify(songData, null, 2)], {
                type: "application/json",
              });

              // Create download link (user can save manually, or we use a service worker)
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = fileName;
              a.click();
              URL.revokeObjectURL(url);

              // Add to marketplace songs
              this.marketplaceSongs.push(songData);

              // Import to recordings
              this.importSong(songData);

              // Update manifest (we'll need to fetch, update, and save)
              await this.updateManifest(fileName);

              this.uploadStatus = `Files downloaded! Please save "${fileName}" and "manifest.json" to the ./songs folder, then refresh the page.`;
              this.uploadStatusType = "success";

              // Reload marketplace to show new song (after user saves files)
              // await this.loadMarketplaceSongs();

              // Clear preview
              setTimeout(() => {
                this.cancelUpload();
                this.uploadStatus = "";
                this.uploadStatusType = "";
              }, 8000);
            } catch (error) {
              console.error("Error saving song:", error);
              this.uploadStatus = "Error saving song: " + error.message;
              this.uploadStatusType = "error";
            }
          },

          async updateManifest(fileName) {
            try {
              // Try to load existing manifest
              const manifestResponse = await fetch("./songs/manifest.json");
              let manifest = { songs: [] };

              if (manifestResponse.ok) {
                manifest = await manifestResponse.json();
              }

              // Add new file if not already present
              if (!manifest.songs.includes(fileName)) {
                manifest.songs.push(fileName);

                // Create updated manifest blob
                const blob = new Blob([JSON.stringify(manifest, null, 2)], {
                  type: "application/json",
                });

                // Download updated manifest
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "manifest.json";
                a.click();
                URL.revokeObjectURL(url);
              }
            } catch (error) {
              console.error("Error updating manifest:", error);
              // Non-critical error, continue anyway
            }
          },

          parseMidiFile(arrayBuffer, fileName) {
            try {
              const data = new Uint8Array(arrayBuffer);
              const events = [];
              let currentTime = 0;
              let i = 0;

              // Skip MIDI header (14 bytes)
              if (data.length < 14) return null;

              // Check for MIDI header
              if (
                String.fromCharCode(data[0], data[1], data[2], data[3]) !==
                "MThd"
              ) {
                return null;
              }

              // Skip to track data
              i = 14;
              let tempo = 500000; // Default tempo (microseconds per quarter note)

              // Find tempo and notes
              while (i < data.length - 8) {
                // Look for track chunk
                if (
                  i + 4 < data.length &&
                  String.fromCharCode(
                    data[i],
                    data[i + 1],
                    data[i + 2],
                    data[i + 3]
                  ) === "MTrk"
                ) {
                  i += 4;
                  const trackLength =
                    (data[i] << 24) |
                    (data[i + 1] << 16) |
                    (data[i + 2] << 8) |
                    data[i + 3];
                  i += 4;
                  const trackEnd = i + trackLength;

                  let trackTime = 0;

                  while (i < trackEnd && i < data.length - 1) {
                    // Read delta time (variable length)
                    let delta = 0;
                    let byte = data[i++];
                    delta = byte & 0x7f;
                    while (byte & 0x80 && i < data.length) {
                      byte = data[i++];
                      delta = (delta << 7) | (byte & 0x7f);
                    }

                    trackTime += delta;

                    if (i >= data.length) break;

                    const status = data[i++];
                    const eventType = status & 0xf0;

                    if (eventType === 0x90) {
                      // Note On
                      const note = data[i++];
                      const velocity = data[i++];

                      if (velocity > 0 && note >= 21 && note <= 108) {
                        const time = (trackTime * tempo) / (480 * 1000000); // Convert to seconds
                        events.push({
                          time: time,
                          type: "on",
                          midi: note,
                          sustain: true,
                        });
                      }
                    } else if (
                      eventType === 0x80 ||
                      (status === 0x90 && data[i + 1] === 0)
                    ) {
                      // Note Off
                      const note = eventType === 0x80 ? data[i++] : data[i - 1];
                      i++; // Skip velocity

                      if (note >= 21 && note <= 108) {
                        const time = (trackTime * tempo) / (480 * 1000000);
                        events.push({
                          time: time,
                          type: "off",
                          midi: note,
                          sustain: true,
                        });
                      }
                    } else if (status === 0xff && data[i] === 0x51) {
                      // Tempo change
                      i++;
                      const tempoBytes = data.slice(i, i + 3);
                      tempo =
                        (tempoBytes[0] << 16) |
                        (tempoBytes[1] << 8) |
                        tempoBytes[2];
                      i += 3;
                    } else {
                      // Skip other events
                      if (eventType === 0xc0 || eventType === 0xd0) {
                        i++; // One data byte
                      } else if (eventType === 0xe0 || eventType === 0xb0) {
                        i += 2; // Two data bytes
                      }
                    }
                  }
                } else {
                  i++;
                }
              }

              // Sort events by time
              events.sort((a, b) => a.time - b.time);

              if (events.length > 0) {
                return {
                  name: fileName.replace(/\.[^/.]+$/, ""),
                  composer: "Unknown",
                  description: "Converted from MIDI",
                  data: events,
                };
              }
            } catch (error) {
              console.error("MIDI parsing error:", error);
            }

            return null;
          },

          noteToMidi(noteName, octave) {
            const noteMap = {
              C: 0,
              "C#": 1,
              Db: 1,
              D: 2,
              "D#": 3,
              Eb: 3,
              E: 4,
              F: 5,
              "F#": 6,
              Gb: 6,
              G: 7,
              "G#": 8,
              Ab: 8,
              A: 9,
              "A#": 10,
              Bb: 10,
              B: 11,
            };

            // Handle sharp/flat notation
            let baseNote = noteName;
            let isSharp = noteName.includes("#");
            let isFlat = noteName.includes("b");

            if (isSharp) {
              baseNote = noteName.replace("#", "");
            } else if (isFlat) {
              baseNote = noteName.replace("b", "");
            }

            const noteValue =
              noteMap[baseNote] || noteMap[baseNote.toUpperCase()];
            if (noteValue === undefined) return -1;

            const midiNote = (octave + 1) * 12 + noteValue;
            return midiNote;
          },

          // Editor methods
          openEditor(recordingIndex) {
            this.showEditor = true;
            this.editorPlaying = false;

            if (recordingIndex === null) {
              // Create new
              this.editorName = `Recording ${new Date().toLocaleTimeString()}`;
              this.editorNotes = [];
            } else {
              // Edit existing
              const recording = this.recordings[recordingIndex];
              if (!recording) return;

              this.editorName = recording.name;
              this.editorNotes = eventsToNotes(recording.data);
            }

            this.$nextTick(() => {
              const canvas = this.$refs.editorCanvas;
              if (!canvas) return;

              this.editorInstance = new SongEditor(canvas, this.pianoKeys, {
                keyHeight: 20,
                pixelsPerSecond: 100,
                keyLabelWidth: 80,
                timelineHeight: 40,
              });

              this.editorInstance.setNotes(this.editorNotes);

              // Sync notes when editor modifies them
              const originalDraw = this.editorInstance.draw.bind(
                this.editorInstance
              );
              this.editorInstance.draw = () => {
                originalDraw();
                // Update reactive notes array
                this.editorNotes = [...this.editorInstance.notes];
              };

              // Handle canvas resize
              const resizeObserver = new ResizeObserver(() => {
                if (this.editorInstance) {
                  this.editorInstance.resize();
                }
              });
              resizeObserver.observe(canvas);
              this.editorResizeObserver = resizeObserver;

              // Keyboard shortcuts
              const handleKeyDown = (e) => {
                if (!this.showEditor) return;

                if ((e.ctrlKey || e.metaKey) && e.key === "c") {
                  e.preventDefault();
                  this.editorCopy();
                } else if ((e.ctrlKey || e.metaKey) && e.key === "v") {
                  e.preventDefault();
                  this.editorPaste();
                } else if ((e.ctrlKey || e.metaKey) && e.key === "a") {
                  e.preventDefault();
                  this.editorSelectAll();
                } else if (e.key === "Delete" || e.key === "Backspace") {
                  e.preventDefault();
                  this.editorDelete();
                }
              };

              window.addEventListener("keydown", handleKeyDown);
              this.editorKeyHandler = handleKeyDown;
            });
          },

          closeEditor() {
            if (this.editorKeyHandler) {
              window.removeEventListener("keydown", this.editorKeyHandler);
              this.editorKeyHandler = null;
            }

            if (this.editorResizeObserver) {
              this.editorResizeObserver.disconnect();
              this.editorResizeObserver = null;
            }

            if (this.editorPlaybackInfo) {
              this.stopEditorPlayback();
            }

            this.showEditor = false;
            this.editorInstance = null;
            this.editorNotes = [];
            this.editorClipboard = [];
          },

          get editorSelectedCount() {
            if (!this.editorInstance) return 0;
            return this.editorInstance.selectedNotes.size;
          },

          editorCopy() {
            if (!this.editorInstance) return;
            this.editorInstance.copySelected();
            this.editorClipboard = this.editorInstance.clipboard;
          },

          editorPaste() {
            if (!this.editorInstance) return;
            this.editorInstance.paste();
            this.editorNotes = [...this.editorInstance.notes];
          },

          editorDelete() {
            if (!this.editorInstance) return;
            this.editorInstance.deleteSelected();
            this.editorNotes = [...this.editorInstance.notes];
          },

          editorSelectAll() {
            if (!this.editorInstance) return;
            this.editorInstance.selectedNotes.clear();
            this.editorInstance.notes.forEach((note) => {
              this.editorInstance.selectedNotes.add(note);
            });
            this.editorInstance.draw();
          },

          editorDeselectAll() {
            if (!this.editorInstance) return;
            this.editorInstance.selectedNotes.clear();
            this.editorInstance.draw();
          },

          editorSave() {
            if (!this.editorName.trim()) {
              alert("Please enter a song name");
              return;
            }

            const events = notesToEvents(this.editorNotes);

            const saved = JSON.parse(
              localStorage.getItem("pianoRecordings") || "[]"
            );

            // If editing, find and update the recording
            const existingIndex = this.recordings.findIndex(
              (r) => r.name === this.editorName
            );

            if (existingIndex >= 0) {
              saved[existingIndex] = { name: this.editorName, data: events };
            } else {
              saved.push({ name: this.editorName, data: events });
            }

            localStorage.setItem("pianoRecordings", JSON.stringify(saved));
            this.loadRecordings();
            this.closeEditor();
          },

          editorPlay() {
            if (this.editorPlaying) {
              this.stopEditorPlayback();
              return;
            }

            if (this.editorNotes.length === 0) return;

            this.editorPlaying = true;

            const sortedNotes = [...this.editorNotes].sort(
              (a, b) => a.startTime - b.startTime
            );
            const lastNote = sortedNotes[sortedNotes.length - 1];
            const duration = lastNote ? lastNote.endTime + 0.5 : 0;

            const playbackInfo = {
              nodes: [],
              startTime: performance.now(),
              duration: duration,
            };

            this.editorPlaybackInfo = playbackInfo;

            // Play all notes
            sortedNotes.forEach((note) => {
              const startDelay = note.startTime * 1000;
              const endDelay = note.endTime * 1000;

              const startTimer = setTimeout(() => {
                const noteName =
                  NOTES[note.midi % 12] + Math.floor(note.midi / 12 - 1);
                MIDI.triggerAttack(noteName, undefined, this.playbackVol);
              }, startDelay);

              const endTimer = setTimeout(() => {
                if (!note.sustain) {
                  const noteName =
                    NOTES[note.midi % 12] + Math.floor(note.midi / 12 - 1);
                  MIDI.triggerRelease(noteName);
                }
              }, endDelay);

              playbackInfo.nodes.push(startTimer, endTimer);
            });

            const cleanupTimer = setTimeout(() => {
              this.stopEditorPlayback();
            }, duration * 1000 + 100);

            playbackInfo.nodes.push(cleanupTimer);
          },

          stopEditorPlayback() {
            if (!this.editorPlaybackInfo) return;

            this.editorPlaybackInfo.nodes.forEach((n) => {
              if (typeof n === "number") {
                clearTimeout(n);
              }
            });

            // Stop all notes
            for (let midi = 21; midi <= 108; midi++) {
              const noteName = NOTES[midi % 12] + Math.floor(midi / 12 - 1);
              try {
                MIDI.triggerRelease(noteName);
              } catch (e) {
                // Ignore errors
              }
            }

            this.editorPlaybackInfo = null;
            this.editorPlaying = false;
          },
        };
      }
    </script>
  </body>
</html>
